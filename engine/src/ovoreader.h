#pragma once

//////////////
// #INCLUDE //
//////////////  

   // GLM:   
#define GLM_FORCE_CTOR_INIT         // Constructors no longer init to identity since 0.9.9
#include <glm/glm.hpp>
#include <glm/gtc/packing.hpp>

// C/C++:
#include <vector>   
#include <map>
#include <iostream>
#include <iomanip>   
#include <limits.h>

using namespace std;

#include "lib.h"
#include "node.h"
#include "material.h"
#include "mesh.h"
#include "light.h"
#include "directionalLight.h"
#include "omnidirectionalLight.h"
#include "positionalLight.h"
#include "spotLight.h"
#include "lightType.h"


/////////////
// #DEFINE //
/////////////

   // General:
#define APP_NAME "OVO Reader v0.8.1r"

// Macro for printing an OvMatrix4 to console:   
#define MAT2STR(m) std::cout << "   Matrix  . . . :  \t" << m[0][0] << "\t" << m[1][0] << "\t" << m[2][0] << "\t" << m[3][0] << std::endl \
                           << "                    \t" << m[0][1] << "\t" << m[1][1] << "\t" << m[2][1] << "\t" << m[3][1] << std::endl \
                           << "                    \t" << m[0][2] << "\t" << m[1][2] << "\t" << m[2][2] << "\t" << m[3][2] << std::endl \
                           << "                    \t" << m[0][3] << "\t" << m[1][3] << "\t" << m[2][3] << "\t" << m[3][3] << std::endl 


/////////////
// CLASSES //
/////////////

/**
* \class OvObject
* \brief Stripped-down redefinition of OvObject (just for the chunk IDs).
* 
 * OvObject is a class containing an enum 'Type'. The latter is used for identifying all the possible types of chunks contianed in a .ovo file.
 * Only few of this types are handled in the project, altought a definition for all types is present for better compatibility.
 */
class LIB_API OvObject {
public:
    /**
    * \enum Type
    * \brief Enumeration of the different subtypes contained in a .ovo.
     */
    enum class Type : int  ///< Type of entities
    {
        // Foundation types:
        OBJECT = 0,
        NODE,
        OBJECT2D,
        OBJECT3D,
        LIST,

        // Derived classes:
        BUFFER,
        SHADER,
        TEXTURE,
        FILTER,
        MATERIAL,
        FBO,
        QUAD,
        BOX,
        SKYBOX,
        FONT,
        CAMERA,
        LIGHT,
        BONE,
        MESH,	   // Keep them...
        SKINNED, // ...consecutive        
        INSTANCED,
        PIPELINE,
        EMITTER,

        // Animation type
        ANIM,

        // Physics related:
        PHYSICS,

        // Terminator:
        LAST,
    };
};

/**
 * \class OvMesh
 * \brief Stripped-down redefinition of OvMesh (just for the subtypes).
 */
class LIB_API OvMesh
{
public:
    /**
     * \enum Subtype
     * \brief OvMesh subtypes enum.
     */
    enum class Subtype : int ///< Kind of mesh
    {
        // Foundation types:
        DEFAULT = 0,
        NORMALMAPPED,
        TESSELLATED,

        // Terminator:
        LAST,
    };
};

/**
 * \class OvLight
 * \brief Stripped-down redefinition of OvLight (just for the subtypes).
 */
class LIB_API OvLight
{
public:
    /**
     * \enum Subtype
     * \brief OvLight subtypes enum.
     */
    enum class Subtype : int ///< Kind of light
    {
        // Foundation types:
        OMNI = 0,
        DIRECTIONAL,
        SPOT,

        // Terminator:
        LAST,
    };
};

/**
 * \class Ovoreader
 * \brief OvoReader class that describes an .ovo 3D models parser.
 * 
 * The OvoReader class is responsible for reading and parsing a given .ovo file.
 * It returns a scene graph generated by the .ovo file, containing the read Nodes, Meshes, Lights, Materials and Textures.
 */
class LIB_API Ovoreader {
public:

    /**
     * \brief Parse a 3D Ovo model into a scene graph.
     * 
     * \param path Path of the Ovo 3D model file.
     * \param texturesDir (Optional) Path where textures are stored, default '.\\assets'.
     * \return Scene graph that describes the read 3D model.
     */
    Node* readFile(const char* path, const char* texturesDir);
protected:

    /**
     * \var m_materials
     * \brief Map composed by tuple <Material name, Material*> containing all the read materials.
     * 
     * m_materials is a member variable used for storing all the read materials. Since materials are specified at the beginning of a .ovo file and are then referenced by
     * Meshes through the material name, the materials need to be stored independently.
     */
    std::map<string, Material*> m_materials;

    /**
     * \brief Recursively load all nodes of a 3D Ovo model.
     *
     * \param dat FILE* containing the 3D Ovo model.
     * \param path Path of the Ovo 3D model file (only used for file name).
     * \return Scene graph that describes the read 3D model.
     */
    Node* recursiveLoad(FILE* dat, const char* path);

    /**
     * \brief Parse chunk with ID 'Object'.
     *
     * \param data char* containing the chunk's data.
     * \param position Pointer used for parsing the chunk.
     */
    void parseOject(char* data, const unsigned int& position);

    /**
     * \brief Parse chunk with ID 'Material'.
     *
     * \param data char* containing the chunk's data.
     * \param position Pointer used for parsing the chunk.
     * \param textureDir Path where textures are stored.
     * \return Material* containing the read Material.
     */
    Material* parseMaterial(char* data, unsigned int& position, const char* textureDir);

    /**
     * \brief Parse chunk with ID 'Node'.
     *
     * \param data char* containing the chunk's data.
     * \param position Pointer used for parsing the chunk.
     * \param nChildren Number of children owned by the Node.
     * \return Node* containing the read Node.
     */
    Node* parseNode(char* data, unsigned int& position, unsigned int* nChildren);

    /**
     * \brief Parse chunk with ID 'Mesh'.
     *
     * \param data char* containing the chunk's data.
     * \param position Pointer used for parsing the chunk.
     * \param nChildren Number of children owned by the Mesh.
     * \return Mesh* containing the read Mesh.
     */
    Mesh* parseMesh(char* data, unsigned int& position, unsigned int* nChildren);

    /**
     * \brief Parse chunk with ID 'Light'.
     *
     * \param data char* containing the chunk's data.
     * \param position Pointer used for parsing the chunk.
     * \param nChildren Number of children owned by the Light.
     * \return Light* containing the read Light.
     */
    Light* parseLight(char* data, unsigned int& position, unsigned int* nChildren);
};